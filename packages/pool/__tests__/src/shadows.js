import Phaser from 'phaser';

import {Pool, Watcher} from '@browndragon/pool';
import SG from '@browndragon/sg';

/** A pool that exports tiles which are "pressure sensitive", with outer corners red and inner corners green. */
class TestPool extends Pool(SG.Group) {
    constructor(scene) {
        super(scene);
        if (!scene.textures.exists(sWhitePixel)) {
            scene.textures.generate(sWhitePixel, {
                pixelWidth:16, pixelHeight:16,
                data: ['2',],
            });
        }
        this.defaultKey = sWhitePixel;
    }
    conformTile({go, tile, u, v}, oldTile) {
        if (tile == oldTile) {
            // We're fine.
            return;
        }
        const scene = go.scene;
        // Something's changing; remove all tweens so we can make the change.
        scene.tweens.killTweensOf(go);
        if (tile) {
            const initial = {
                // tintTopLeft: Phaser.Display.Color.IntegerToColor(go.tintTopLeft),
                // tintTopRight: Phaser.Display.Color.IntegerToColor(go.tintTopRight),
                // tintBottomLeft: Phaser.Display.Color.IntegerToColor(go.tintBottomLeft),
                // tintBottomRight: Phaser.Display.Color.IntegerToColor(go.tintBottomRight),
                tintTopLeft: go.tintTopLeft,
                tintTopRight: go.tintTopRight,
                tintBottomLeft: go.tintBottomLeft,
                tintBottomRight: go.tintBottomRight,
            };
            const target = {
                tintTopLeft: tile & kTL ? kSet : kNot,
                tintTopRight: tile & kTR ? kSet : kNot,
                tintBottomLeft: tile & kBL ? kSet : kNot,
                tintBottomRight: tile & kBR ? kSet : kNot,
            };
            scene.tweens.add({
                targets:go,
                props: {
                    alpha: 1,
                    // tintTopLeft: tile & kTL ? kSet : kNot,
                    // tintTopRight: tile & kTR ? kSet : kNot,
                    // tintBottomLeft: tile & kBL ? kSet : kNot,
                    // tintBottomRight: tile & kBR ? kSet : kNot,
                },
                onUpdate: (tween) => go.setTintFill(
                    interpolate(initial.tintTopLeft, target.tintTopLeft, tween.progress),
                    interpolate(initial.tintTopRight, target.tintTopRight, tween.progress),
                    interpolate(initial.tintBottomLeft, target.tintBottomLeft, tween.progress),
                    interpolate(initial.tintBottomRight, target.tintBottomRight, tween.progress),
                ),
                duration: 250,
            });
        } else {
            scene.tweens.add({
                targets:go,
                props: {
                    alpha: 0,
                },
                onComplete: () => this.removeTileUV(u, v),
                duration: 250,
            });
        }
    }

    prepareTileGameObject(u, v) {
        let tile = super.prepareTileGameObject(u, v);
        tile.alpha = 0;
        return tile;
    }
}
export default class Shadows extends Watcher(SG.Group, TestPool) {
    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        this.updateShadows();
    }
}

const sWhitePixel = 'AutogeneratedWhitePixel';

// const kSet = Phaser.Display.Color.IntegerToColor(0x00FF00);
// const kNot = Phaser.Display.Color.IntegerToColor(0xFF0000);
const kSet = 0x00FF00;
const kNot = 0xFF0000;

const kTL = 0b1000;
const kTR = 0b0001;
const kBL = 0b0100;
const kBR = 0b0010;

function interpolate(oV, nV, r) {
    let nr = 1-r;
    let color = 0;
    for (let i of [2, 1, 0]) {
        0xFF; 
        const shift = 8 * i;
        color |= Math.floor((nr * (0xFF & (oV >> shift)) + r * (0xFF & (nV >> shift)))) << shift;
    }
    return color;
}
